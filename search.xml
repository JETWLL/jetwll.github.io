<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[什么是 JavaScript 深度拷贝]]></title>
      <url>http://www.jetwll.com/2017/04/11/%E4%BB%80%E4%B9%88%E6%98%AF-JavaScript-%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>面试的时候碰到了这么个问题，在这里总结一下。<br>什么是 Javacript 深度拷贝，既然有深度拷贝，那有没有浅度拷贝呢？答案是有的。<br><a id="more"></a></p>
<p>举个简单的例子解释一下：</p>
<blockquote>
<p><strong>浅度拷贝</strong>：就好比我们从俄罗斯买了20架苏27战斗机，飞机人家是给你了，但是技术并没转让，飞机坏了还得求人家来给你修。</p>
<p><strong>深度拷贝</strong>：就好比我们从俄罗斯买了20架苏27战斗机，并且转让了全部技术，这样，我们就能自己生产了，技术全挖过来了，俄罗斯管不着了。</p>
</blockquote>
<h4 id="第一节-对象的拷贝"><a href="#第一节-对象的拷贝" class="headerlink" title="第一节 对象的拷贝"></a>第一节 对象的拷贝</h4><h5 id="1、浅度拷贝"><a href="#1、浅度拷贝" class="headerlink" title="1、浅度拷贝"></a>1、浅度拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'aa'</span>,</div><div class="line">    <span class="attr">age</span>:<span class="string">'20'</span></div><div class="line">&#125;</div><div class="line">b = a;</div><div class="line">b; <span class="comment">//结果如下</span></div><div class="line"><span class="comment">/*</span></div><div class="line">b = &#123;</div><div class="line">    name:'aa',</div><div class="line">    age:'20'</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>问：我们将对象 a 作一下修改，b 是否会跟着变？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'aa'</span>,</div><div class="line">    <span class="attr">age</span>:<span class="string">'20'</span></div><div class="line">&#125;</div><div class="line">b = a;</div><div class="line"><span class="comment">// 那么</span></div><div class="line">b = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'aa'</span>,</div><div class="line">    <span class="attr">age</span>:<span class="string">'20'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">a.name = <span class="string">'cc'</span>;</div><div class="line">b;</div><div class="line"><span class="comment">/* b = &#123; name:'cc',age:'20' &#125; */</span></div></pre></td></tr></table></figure></p>
<p>对象 b 是会跟着对象 a 的变动而变化的，这个我想大家应该都明白。</p>
<h5 id="2、深度拷贝"><a href="#2、深度拷贝" class="headerlink" title="2、深度拷贝"></a>2、深度拷贝</h5><p>就是 a 对象的操作不会影响到 b 对象(当然，反过来亦如此)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'yy'</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">26</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="comment">// 注意重点来了</span></div><div class="line">b.name=a.name;</div><div class="line">b.age=a.age;</div><div class="line"></div><div class="line">a.name=<span class="string">'xx'</span>;</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"><span class="comment">//Object &#123; name="yy", age=26&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="comment">//Object &#123; name="xx", age=26&#125;</span></div></pre></td></tr></table></figure></p>
<p>哎呦，还真是，对象 a 变了而对象 b 没发生变化。</p>
<p>总结一下，其实是这样的。<br>1.浅度拷贝：基本类型为值传递，对象仍为引用传递。<br>2.深度拷贝：所有元素或属性完全克隆，对于原引用类型完全独立。</p>
<p>上面这种写法，对象属性很少的情况下，是可以使用的，但是多了，就不行了。所以我们还是要写个函数，将要拷贝的对象的属性遍历一遍，赋值给一个新对象。如下，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">source</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</div><div class="line">        result[key] = <span class="keyword">typeof</span> source[key] === <span class="string">'object'</span>? deepCoyp(source[key]): source[key];</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> result;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">18</span></div><div class="line">&#125;</div><div class="line">b = deepCopy(a);</div><div class="line"><span class="comment">/* b = &#123; name: '小明'，age：18 &#125;*/</span></div></pre></td></tr></table></figure></p>
<p>同理，说一下数组的浅度拷贝和深度拷贝</p>
<h4 id="第二节-数组的拷贝"><a href="#第二节-数组的拷贝" class="headerlink" title="第二节 数组的拷贝"></a>第二节 数组的拷贝</h4><h5 id="1、浅度拷贝-1"><a href="#1、浅度拷贝-1" class="headerlink" title="1、浅度拷贝"></a>1、浅度拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr;</div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1,2,3]</span></div><div class="line">arr[<span class="number">0</span>] = <span class="string">"one"</span>;</div><div class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// ["one", 2, 3]</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// ["one", 2, 3]</span></div></pre></td></tr></table></figure>
<p>与对象的浅度拷贝是一样的。</p>
<h5 id="2、深度拷贝-1"><a href="#2、深度拷贝-1" class="headerlink" title="2、深度拷贝"></a>2、深度拷贝</h5><p>方法1：利用 slice 函数</p>
<blockquote>
<p>slice() 方法可从已有的数组中返回选定的元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; arrayObject.slice(start,end)  <span class="comment">// start 必选 end 可选</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<br>1.请注意，该方法并不会修改数组，而是返回一个子数组。<br>2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">0</span>); <span class="comment">// 重点看这里</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></div><div class="line">arr = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>];</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["one","two","three"]</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>方法2：利用 concat 函数</p>
<blockquote>
<p>concat() 方法用于连接两个或者多个数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; arrayObject.concat(arrayX,arrayX,......,arrayX)  </div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<br>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr.concat();  <span class="comment">// 重点看这里</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></div><div class="line">arr = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>];</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["one","two","three"]</span></div><div class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>说点题外话，做前端也有一段时间了，碰到问题，就加个书签或者建个 word 简要的记一下。从今年开始认真的在有道云笔记上写笔记，并且把合适的推送到自己的博客上。个人觉得建立博客的意义除了知识共享以及备忘，更重要的一点是迫使自己去思考和总结，既要写出来，还要别人能看懂，花费的时间挺多，但是值得。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度拷贝 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[总结一下数组去重的几个方法]]></title>
      <url>http://www.jetwll.com/2017/04/03/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在前端面试中，数组去重还是一个出现频率比较高的题目,算是一种基本能力吧。<br>以下方法，在我看来，还是比较容易理解的，还有一些其他方法，正在整理中，会陆续更新。<br><a id="more"></a></p>
<h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>关键词：双for循环、splice<br>思  路：将数组中的值一个个的比较，重复的就删掉<br>复杂度：O(n^2)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDup</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = array.length<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</div><div class="line">        <span class="keyword">if</span>(array[j] == array[i])</div><div class="line">          array.splice(j,<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">removeDup(a);</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>关键词：indexOf、push<br>思路：设置一个新数组，根据indexOf筛选原数组，只要新数组中没有的，就push到新数组<br>复杂度：O(n)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDup</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newArray = [];</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(newArray.indexOf(array[i]) == <span class="number">-1</span> ) &#123;</div><div class="line">          newArray.push(array[i]);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> newArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">removeDup(a);</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><p>关键词：es6、Set、Array.from<br>思 路：<br>1、Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化，其成员的值都是唯一的，没有重复的值。<br>2、Array.from()方法可以将类数组对象和可遍历(iterable)的对象转化为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDup</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a));</div><div class="line">&#125;</div><div class="line"></div><div class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">removeDup(a);</div><div class="line"><span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组去重 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 中构造函数与 new 命令]]></title>
      <url>http://www.jetwll.com/2017/03/19/JavaScript%20%E4%B8%AD%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%20new%20%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>典型的面向对象编程语言（比如C++和Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，在 JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。<br><a id="more"></a></p>
<h5 id="1-对象的概念"><a href="#1-对象的概念" class="headerlink" title="1 对象的概念"></a>1 对象的概念</h5><p>“面向对象编程”（Object Oriented Programming，缩写为OOP），是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。总结一下：</p>
<ol>
<li>对象是单个实物的抽象</li>
<li>对象是一个容器，封装了“属性”和“方法”</li>
<li>所谓属性，就是对象的一种状态；所谓方法，就是对象的一种行为</li>
<li>比如说，可以把动物抽象为animal对象，属性记录的就是哪一种动物，以及该动物的大小和颜色等。方法表示该动物的某种行为（奔跑，猎食，交配，休息等等）。</li>
</ol>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h5><ol>
<li>“面向对象编程”的第一步，就是要生成对象。而js中面向对象编程是基于构造函数（constructor）和原型链（prototype）的。</li>
<li>前面说过，“对象”是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。js语言中使用构造函数（constructor）作为对象的模板。</li>
<li>所谓构造函数，就是提供一个生成对象的模板，并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。<h5 id="看一下构造函数的基本结构"><a href="#看一下构造函数的基本结构" class="headerlink" title="看一下构造函数的基本结构"></a>看一下构造函数的基本结构</h5> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> People = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span>; <span class="comment">// 注意这里xiaoyi要加单引号， 不然会认为这个是变量，并且未定义</span></div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 两种写法相同</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'xiaoyi'</span>;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码中，People就是构造函数，它提供模板，用来生成对象实例。（就是可以按照这个方法定义别的变量）。为了与普通函数区别，构造函数名字的第一个字母通常大写（这里的People，不大写也不会报错，但是还是按照规则比较好）。</p>
<h5 id="构造函数的三大特点："><a href="#构造函数的三大特点：" class="headerlink" title="构造函数的三大特点："></a>构造函数的三大特点：</h5><ol>
<li>构造函数的函数名的第一个字母通常大写。</li>
<li>函数体内使用this关键字，代表所要生成的对象实例。</li>
<li>生成对象的时候，必须使用 new 命令来调用构造函数。</li>
</ol>
<h5 id="3-new-命令"><a href="#3-new-命令" class="headerlink" title="3 new 命令"></a>3 new 命令</h5><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>new 命令的作用，就是执行一个构造函数，并且返回一个对象实例。使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将空对象的原型指向了构造函数的prototype属性。</li>
<li>将空对象赋值给构造函数内部的this关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<p>　　也就是说，构造函数内部，this指向的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所谓构造函数，意思是这个函数的目的就是操作一个空对象（即this对象），将其构造为需要的样子。</p>
<p>　　以上是 new 命令的基本原理，这个很重要。以下会用具体实例来验证该原理的过程。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>new 命令的作用，就是调用一个构造函数，并且返回一个对象实例。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = <span class="keyword">new</span> People();</div><div class="line"><span class="built_in">console</span>.log(wll.age);</div></pre></td></tr></table></figure></p>
<p>上面代码通过 new 命令，让构造函数 People 生成一个对象实例，并赋值给全局变量 wll。这个新生成的对象实例，从构造函数 People 中继承了 age 属性。同时说明这个对象实例是没有 age 属性的。在 new 命令执行时，就代表了新生成的对象实例 wll，this.age 表示对象实例有一个age属性，它的值是25。</p>
<h6 id="使用-new-命令时，根据需要，构造函数也可以接受参数。"><a href="#使用-new-命令时，根据需要，构造函数也可以接受参数。" class="headerlink" title="使用 new 命令时，根据需要，构造函数也可以接受参数。"></a>使用 new 命令时，根据需要，构造函数也可以接受参数。</h6><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> wll = <span class="keyword">new</span> People(<span class="string">'wangleilei'</span>, <span class="number">25</span>);</div><div class="line"><span class="built_in">console</span>.log(wll.name); <span class="comment">// wangleilei</span></div><div class="line"><span class="built_in">console</span>.log(wll.age); <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(wll); <span class="comment">// People &#123;name: "wangleilei", age: 25&#125;</span></div></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>上面代码中，我们创建了一个构造函数People，传入了两个参数 name 和age，构造函数 People 内部使用了 this 关键字来指向将要生成的对象实例。</p>
</li>
<li><p>然后，我们使用 new 命令来创建对象实例 wll。</p>
</li>
<li><p>当我们使用 new 命令来调用构造函数时，new 命令会创建一个空对象 wll，作为将要返回的实例对象。接着，这个空对象的原型会指向构造函数 People 的prototype属性，即 People.prototype。</p>
</li>
<li><p>然后我们将这个空对象赋值给构造函数内部的this关键字，也就是说，让构造函数内部的this关键字指向一个对象实例。最后，开始执行构造函数内部的代码。</p>
</li>
<li><p>因为对象实例 wll 是没有 name和age属性的，所以对象实例中的两个属性都是继承自构造函数 People中的，这也说明了构造函数是生成对象的函数，是给对象提供模板的函数。</p>
</li>
</ol>
<h6 id="一个问题，如果我们忘记使用-new-命令来调用构造函数，直接调用构造函数了，会发生什么？"><a href="#一个问题，如果我们忘记使用-new-命令来调用构造函数，直接调用构造函数了，会发生什么？" class="headerlink" title="一个问题，如果我们忘记使用 new 命令来调用构造函数，直接调用构造函数了，会发生什么？"></a>一个问题，如果我们忘记使用 new 命令来调用构造函数，直接调用构造函数了，会发生什么？</h6><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = People();</div><div class="line"><span class="built_in">console</span>.log(wll); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(wll.age); <span class="comment">// TypeError: wll is undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</code></pre><p>可见，这种情况下，构造函数变成了普通函数，并不会生成实例对象（wll 是 undefined）<br>并且，this 指向了全局作用域（如果有 new 则不会），age 也就变成了全局变量。</p>
<h6 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h6><p>1、 在构造函数内部使用严格模式，即第一行加上use strict。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = People();</div><div class="line"><span class="built_in">console</span>.log(wll); <span class="comment">// Cannot set property 'age' of undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);<span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>严格模式下，函数内部的 this 不能指向全局对象，即便指向了全局，this 默认值等于undefined（如上代码）。<br>2、另一个解决办法，是在构造函数内部判断是否使用 new 命令，如果发现没有使用，则直接返回一个实例对象。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">age</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> People)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> People(age);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = People(<span class="number">25</span>);</div><div class="line"><span class="built_in">console</span>.log(wll.age); <span class="comment">// 25</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，构造函数不管加不加new命令，都会得到同样的结果。</p>
<p>3、 如果构造函数内部有 return 语句，而且 return 后面跟着一个复杂数据类型（对象，数组等），new 命令会返回 return 语句指定的对象；如果 return 语句后面跟着一个简单数据类型（字符串，布尔值，数字等），则会忽略 return 语句，返回 this 对象。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">age</span>: <span class="number">26</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = <span class="keyword">new</span> People();</div><div class="line"><span class="built_in">console</span>.log(wll.age); <span class="comment">//26</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">27</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = <span class="keyword">new</span> People();</div><div class="line"><span class="built_in">console</span>.log(wll.age); <span class="comment">//25</span></div></pre></td></tr></table></figure></p>
<p>4、另一方面，如果对普通函数（内部没有this关键字的函数）使用 new 命令，则会返回一个空对象。<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'its a message'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> wll = <span class="keyword">new</span> People();</div><div class="line"><span class="built_in">console</span>.log(wll); <span class="comment">// People &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，对普通函数 People 使用 new 命令，会创建一个空对象。这是因为 new 命令总<br>是返回一个对象，要么是实例对象，要么是 return 语句指定的对象或数组。本例中，return 语句返回的是字符串，所以 new 命令就忽略了该语句。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 构造函数 </tag>
            
            <tag> New 命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解 JavaScript 作用域]]></title>
      <url>http://www.jetwll.com/2017/03/17/%E8%AF%A6%E8%A7%A3%20JavaScript%20%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p> JavaScript 的作用域一直是前端开发和前端面试中难以理解的知识点，一不留神就入坑了，小编写这篇文章，就是来填坑的，好了，直接开始。<br><a id="more"></a></p>
<h5 id="1-JavaScript-无块级作用域"><a href="#1-JavaScript-无块级作用域" class="headerlink" title="1. JavaScript 无块级作用域"></a>1. JavaScript 无块级作用域</h5><p>什么是块级作用域？其实就是占地盘，画个圈圈说这块地盘是我的，只有我能在这个区域里作，例如，这个 “{ }” 大括号。<br>那无块级作用域又是什么意思呢？就是即便你画了个圈，但凭啥你说这是你地盘就是你地盘，我在圈外面就想插一脚玩玩。<br>例子1：<br>JavaScript 无块级作用域<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)  </span>&#123; </div><div class="line">     <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">          <span class="keyword">var</span> name = <span class="string">'yes'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;;</div><div class="line">Fun();</div><div class="line"><span class="comment">// yes</span></div></pre></td></tr></table></figure></p>
<p>这里 if(true) 后面的 {…} 是一个块级作用域，根据输出结果，可以知道 console.log(name) 是可以访问 var name = ‘yes’ 的，等同于别人在你家门外就能拿你家里的东西。<br>不过在 ES6 中，引入了 let 关键字，用于指定变量属于块级作用域。也就是说JavaScript 也有块级作用域了。<br>例子2：<br>JavaScript 有块级作用域<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)  </span>&#123; </div><div class="line">     <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">          <span class="keyword">let</span> name = <span class="string">'yes'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;;</div><div class="line">Fun();</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>引用 let 替换 var 后，生成了块级作用域，console.log(name) 访问不到大括号里面的内容了。</p>
<h5 id="2-JavaScript-函数作用域"><a href="#2-JavaScript-函数作用域" class="headerlink" title="2. JavaScript 函数作用域"></a>2. JavaScript 函数作用域</h5><p>JavaScript 中每个函数作为一个作用域，外部是无法访问作用域内部的变量的。<br>例子3：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(x); </div><div class="line">&#125;</div><div class="line">Fun();</div><div class="line"><span class="built_in">console</span>.log(y);</div><div class="line"><span class="comment">// 1   ReferenceError: y is not defined......</span></div></pre></td></tr></table></figure></p>
<p>“函数作用域”还是比较厉害的，自己家的东西管的很严格，别人看都不让看。</p>
<h5 id="3-JavaScript-作用域链"><a href="#3-JavaScript-作用域链" class="headerlink" title="3. JavaScript 作用域链"></a>3. JavaScript 作用域链</h5><p>JavaScript中的每个函数作为一个作用域，如果出现函数之间互相嵌套，就会出现作用域链。<br>例子4：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">            <span class="built_in">console</span>.log(x);</div><div class="line">      &#125;</div><div class="line">      main();</div><div class="line">&#125;</div><div class="line">Fun();</div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>两个函数互相嵌套，形成三个作用域组成的作用域链（不要忘记全局作用域），这种情况下，寻找变量就要按照顺序。</p>
<p>执行console.log(x)时，按照作用域有内而外的优先级寻找，很明显，应该先在<br>       <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">   <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找到了 var x = 3，最后结果就是3。修改例子3，如下：<br>     <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">    main();</div><div class="line">&#125;</div><div class="line">Fun();</div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>依次类推，如果最后找不到则报错。</p>
<p>这里，顺便讲一下JavaScript 变量提升。</p>
<h5 id="4-JavaScript-变量提升"><a href="#4-JavaScript-变量提升" class="headerlink" title="4. JavaScript 变量提升"></a>4. JavaScript 变量提升</h5><p>有时候也称之为声明提前，变量声明提升等等，其实都是一个意思。<br>什么是变量提升，即变量可以在声明之前使用，说的简单点，就是声明的这个变量它比较喜欢往前凑热闹。</p>
<ol>
<li><p>JavaScript 中不创建变量，直接使用，结果是报错的</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="comment">// ReferenceError: x is not defined...</span></div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>创建变量但是不赋值，结果是 undefined</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x;</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>创建变量并赋值，结果输出正常</p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<p>注意：这里 var x = 3  在实际执行过程中是这样的，明白这点很重要。<br>        <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x;</div><div class="line">x = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>我们看下面这个例子<br>例子5：<br>        <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">    <span class="keyword">var</span> x = <span class="string">'5'</span>;</div><div class="line">&#125;</div><div class="line">Fun();</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>为什么输出的是 undefined，而不是直接报错或者输出“5”呢？请看原因：这个时候，变量提升和刚才的“明白这点很重要”该出马了。在 JavaScript 被执行之前，有一个“预编译”的过程，这期间代码变成这样了<br>        <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x;  <span class="comment">// 看到了没，我跑前面来了哦</span></div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">    x = <span class="string">'5'</span>; <span class="comment">// 赋值语句位置不变，声明语句提前</span></div><div class="line">&#125;</div><div class="line">Fun();</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript作用域 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
